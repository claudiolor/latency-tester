package main

import (
	"gopkg.in/yaml.v2"
	"io/ioutil"
	"log"
	"math"
	"os"
	"sync"
)

type IperfData struct {
	Name string `yaml:"name"`
	Ip   string `yaml:"ip"`
	Port string `yaml:"port"`
}

type PingData struct {
	Name string `yaml:"name"`
	Ip   string `yaml:"ip"`
}

type EndpointData struct {
	Description string `yaml:"description"`
	Destination string `yaml:"destination"`
}

type Settings struct {
	Runs                 int            `yaml:"runs"`
	RunsInterval         int            `yaml:"runs_interval"`      // in minutes
	RunsStepDuration     int            `yaml:"runs_step_duration"` // in seconds
	IperfDestinations    []IperfData    `yaml:"iperf_destinations"`
	PingDestinations     []PingData     `yaml:"ping_destinations"`
	PingInterval         int            `yaml:"ping_interval"` // in seconds
	Endpoints            []EndpointData `yaml:"endpoints"`
	Intervals            []int          `yaml:"intervals"`     // in milliseconds
	MsgSizes             []int          `yaml:"msg_sizes"`     // in bytes
	ResponseSize         int            `yaml:"response_size"` // in bytes
	TcpdumpEnabled       bool           `yaml:"tcpdump_enabled"`
	TlsEnabled           bool           `yaml:"tls_enabled"`
	ExecDir              string         `yaml:"exec_dir"`
	PercentilesToRemove  int            `yaml:"percentiles_to_remove"`
	EqualizationDisabled bool           `yaml:"equalization_disabled"`
	RttMin               float64        `yaml:"rtt_min"`
	RttMax               float64        `yaml:"rtt_max"`
	RunsToPlot           []int          `yaml:"runs_to_plot"`
}

const (
	ENDPOINTS = iota
	INTERVALS = iota
	SIZES     = iota
)

const AxisTicks = 15
const PlotDirName = "plots/"
const LoggerHdr = "|-@plotter     - "

func main() {

	if len(os.Args) == 1 {
		log.Fatal(LoggerHdr + "Settings filename requested")
	}

	// Settings parsing
	log.Println(LoggerHdr + "Opening settings file")
	file, err := ioutil.ReadFile(os.Args[1])
	if err != nil {
		log.Fatal(LoggerHdr+"*** ERROR opening settings file:", err)
	} else {
		log.Println(LoggerHdr + "Settings file successfully opened")
	}
	var settings Settings
	log.Println(LoggerHdr + "Loading settings")
	err = yaml.Unmarshal(file, &settings)
	if err != nil {
		log.Fatal(LoggerHdr+"*** ERROR reading settings:", err)
	} else {
		log.Println(LoggerHdr + "Settings successfully read")
	}

	if settings.RunsStepDuration == 0 && settings.RunsInterval == 0 {
		log.Fatal(LoggerHdr + "One between runs_step_duration and runs_interval must be set")
	}
	combinations := len(settings.Endpoints) * len(settings.Intervals) * len(settings.MsgSizes)
	if settings.RunsStepDuration == 0 {
		settings.RunsStepDuration = settings.RunsInterval * 60 / combinations
	}
	if settings.RunsInterval == 0 {
		settings.RunsInterval = int(math.Ceil(float64(settings.RunsStepDuration*combinations) / 60))
	}

	// Create the file in order that it can be totally handled by the host machine
	log.Println(LoggerHdr + "Creating 'plots' folder")
	err = os.Mkdir(settings.ExecDir+PlotDirName, os.ModePerm)
	if err != nil {
		log.Println(LoggerHdr + err.Error())
	}

	log.Println(LoggerHdr + "Creating README file")
	readme, err := os.Create(settings.ExecDir + PlotDirName + "README.txt")
	if err != nil {
		log.Fatal(LoggerHdr+"Cannot create README file:", err)
	} else {
		log.Println(LoggerHdr + "README file successfully created")
	}
	readme.WriteString("Latency Tester - Plotter\n\n" +
		"Here are the files generated by the plotter:\n" +
		"- summary.txt = A summary of the RTT measurement for each combination of Destination, Interval and Message Size.\n" +
		"- *-tcpPlot.pdf = This plot describes the TCP ACK round trip time variation throughout the execution of each run" +
		" of the enhanced client.\n" +
		"- endpointsBoxPlot.pdf = The BoxPlot representation of endpoints rtt for each interval x size combination.\n" +
		"- intervalsBoxPlot.pdf = The BoxPlot representation of intervals rtt for each size x endpoint combination.\n" +
		"- sizesBoxPlot.pdf = The BoxPlot representation of sizes rtt for each interval x endpoint combination.\n" +
		"- endpointsCDF.pdf = The Cumulative Distribution Function of endpoints rtt for each interval x size combination.\n" +
		"- intervalsCDF.pdf = The Cumulative Distribution Function of intervals rtt for each size x endpoint combination.\n" +
		"- sizesCDF.pdf = The Cumulative Distribution Function of sizes rtt for each interval x endpoint combination.\n" +
		"- pingPlot.pdf = Representation of the variation of the network-level round trip time throughout the execution" +
		" of the enhanced client.\n" +
		"- e2eLatency.pdf = The plotter puts together all the runs regarding each combination of the parameters and plots" +
		" the round trip time variation throughout the execution of the enhanced client.\n" +
		"- e2eLatencyPerRunBoxplot.pdf = A BoxPlot representation of the round trip time during each run of every" +
		" combination of the parameters.")
	readme.Close()

	var wg sync.WaitGroup

	if settings.TcpdumpEnabled {
		runsRequested := requestedSlice(settings)
		wg.Add(len(runsRequested))
		for _, run := range runsRequested {
			go TcpdumpPlotter(settings, run, &wg)
		}
	} else {
		log.Println(LoggerHdr + "Tcpdump was not enabled, so it will generate no tcpPlots")
	}
	if len(settings.PingDestinations) > 0 {
		wg.Add(1)
		go PingPlotter(settings, &wg)
	}
	wg.Add(7)
	go typedBoxPlots(settings, SIZES, &wg)
	go typedBoxPlots(settings, INTERVALS, &wg)
	go typedBoxPlots(settings, ENDPOINTS, &wg)
	go typedCDFs(settings, SIZES, &wg)
	go typedCDFs(settings, INTERVALS, &wg)
	go typedCDFs(settings, ENDPOINTS, &wg)
	// Generates 2 pdfs, standard and boxplots
	go RttPlotter(settings, &wg)
	wg.Wait()
}
